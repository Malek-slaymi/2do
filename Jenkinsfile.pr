pipeline {
  agent { label 'docker' } // adapte à ton agent
  environment {
    APP_DIR = 'frontend'
    IMAGE = "myapp:${env.BRANCH_NAME}-${env.BUILD_NUMBER}"
  }
  triggers { /* none; Multibranch triggers on PR automatically */ }
  stages {
    stage('Checkout') {
      steps { checkout scm }
    }
    stage('Setup') {
      steps {
        dir(APP_DIR) {
          bat 'node -v || true'
          bat 'npm ci'
        }
      }
    }
    stage('Build') {
      steps {
        dir(APP_DIR) {
          bat 'npm run build'
        }
      }
    }

    stage('Run (Docker)') {
      steps {
        dir(APP_DIR) {
          script {
            bat "docker build -t ${IMAGE} ."
            bat "docker run -d --rm -p 8080:80 --name smoke_${BUILD_ID} ${IMAGE}"
            // Give it a bit to start
            bat "sleep 3"
          }
        }
      }
    }

    stage('Smoke Test') {
      steps {
        dir(APP_DIR) {
          // run the smoke script against the running container
          bat "./smoke-test.sh http://localhost:8080 20 || true"
          // ensure smoke-result.json exists
          bat 'cat smoke-result.json || true'
        }
      }
      post {
        success { echo "Smoke stage finished — check smoke-result.json" }
        unsuccessful { echo "Smoke failed — see smoke-result.json" }
      }
    }

    stage('Archive Artifacts') {
      steps {
        archiveArtifacts artifacts: "${APP_DIR}/build/**, ${APP_DIR}/smoke-result.json", fingerprint: true
        junit allowEmptyResults: true, testResults: '**/test-results/*.xml' // si tu as tests unitaires
      }
    }
  }
  post {
    always {
      stage('Cleanup') {
        steps {
          bat "docker ps -a -q --filter name=smoke_${BUILD_ID} | xargs -r docker rm -f || true"
          bat "docker rmi ${IMAGE} || true"
        }
      }
      failure { echo "Pipeline failed - see logs" }
      success { echo "Pipeline succeeded" }
    }
  }
}

